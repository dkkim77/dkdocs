목 차 
1. 분산 캐시
2. 분산 락
3. 클러스터 재합류
4. 멤버쉽 관리

1. 분산 캐시

    * 구현 방식 
              데이터변경 이벤트를 메시지로 송신
    Node A ---------------------------> Node B
    
    JGroups 로 구현 시 
    단점 : n/w 트레픽 고려, 캐시size/TTL 직접 구현 
          n/w 퍄티션이 다시 합쳐지면 캐시 데이터를 동기화  --> 직접 구현
          
2. 분산 락
 
  * 구현 방식 : 한 노드를 leader 로 지정하고 락 요청을 leader 에게 보냄. leader 는 락 상태 변경을 모든 노드에게 broadcast 함
  
  - JGroups 로 구현 시 LockService 클래스를 이용
  - lock() 메소드 호출 시 짧은 timeout 을 주기적으로 사용해 데드락 회피
  
  * n/w 파티션 
  - n/w 장애로 인한 두개의 클러스터로 분할되는 현상
  
        NodeA --- NodeB            NodeC
               |                     |
               -------- 공유 자원 ------
       
       두 개의 클러스터가 공유 자원을 동시 사용하게 되면서 데이터 무결성이 깨짐
       
  - 해법 : Quorum (정족수)
          과반수를 차지하는 파티션이 읽기/쓰기 가능. 그 외 파티션은 읽기만 가능
          zookeeper, etcd 를 이용해서 leader 를 하나만 유지하는 방법 고려
          
  - 사용처 : 이중화된 타이머에서 분산 락 사용. 타이머 그룹에서 하나의 타이머만 실행 가능
  
3. 클러스터 재합류

  - 장애감지 - View 에서 노드 제거 
  - 장애복구 - JChannel.connect(..) 호출되면서 재합류
  - 상태 동기화 구현을 직접 해야 함
  
4. 멤버쉽 관리
  - JChannel.connect 호출 시 코디네이터에게 JOIN 전송 > 코디네이터가 View 에 추가하고 broadcast
  - JChannel.close() 호출 시 LEAVE 이벤트 전송 
  
5. zookeeper 와 비교
  - 서로 다른 목표
  - zookeeper 는 분산락, 리더 선출, 영속적인 중앙 상태 관리, 설정 관리
  - JGroups 는 메시징, 캐시 복제 
                   