1. StreamExample 작성.
- com.unchart.dkbank.framework.kafka.StreamExample 참조

2. 카프카 능숙하게 사용하기.

2.1 Consumer Group

   2.1.1 개요 
- group.id 로 지정한다.
- 카프카 클러스터에서 수신할 메시지를 동일 컨슈머 그룹의 컨슈머들끼리 분산하여 수신한다.
   이런 특성 때문에 컨슈머 그룹은 하나의 데이터 처리를 여러 컨슈머에서 분산 처리하기 위해 사용된다.
   
   2.1.2 컨슈머에서 파티션 할당 
- 하나의 컨슈머에 여러 파타션이 할당될 수도 있다.
- 파티션-컨슈머 매핑은 컨슈머 그룹에 컨슈머가 가입한 경우 필요에 따라 그 때 결정된다.
  이 결정은 컨슈머가 설정되어 있는 Assignor 로직에 따라 실시된다.
- 표준 Assigner
  RoundRobin : 매핑할 파티션을 컨슈머에 하나씩 차례대로 매핑.
  Range         : 매핑할 파티션을 나열하고 컨슈머 수로 영역을 분할하여 할당.
  Sticky         : 최대한 균형있게 할당. 재할당 시 원래 매핑에서 변경되지 않도록 할당.
   
 2.2 Offset Commit
   
   2.2.1 개요.
- 오프셋 커밋의 기록은 컨슈머 그룹 단위로 이루어진다. 그룹마다 각 토픽의 파티션에서 어디까지 처리 완료했는지 정보를 기록한다.
   완료 여부를 메시지마다 기록하는 것이 아니라 완료한 메시지 중에서 최대의 오프셋을 기록하는 형태로 이뤄진다.?????
   
   2.2.2 자동/수동 오프셋 Commit 
- 자동 : 일정 간격마다 자동으로 오프셋 커밋을 수행.
   컨슈머에 장애가 발생했을 때 메시지가 손실되거나 메시지 중복 처리가 발생할 수 있다.
- 수동 : 컨슈머 앱 안에서 KafkaConsumer.commitSync 또는 commitAsync 라는 메소드를 호출.

  2.2.3 자동 오프셋 Reset.
- 컨슈머는 시작할 때 오프셋 커밋 기록이 존재하지 않는 경우, 오프셋이 유효하지 않은 경우 초기화를 실시하여
  시작할 오프셋을 결정한다. 이 초기화가 자동 오프셋 Reset 이다.
- 컨슈머 앱에서 KafkaConsumer 를 생성 시 auto.aoffset.reset 이라는 옵션으로 지정.
   옵션 값
   lastest : 해당 파티션의 가장 새로운 오프셋으로 초기화. 이미 존재하는 메시지는 처리되지 않는다.
   earliest : 해당 파티션에 존재하는 가장 오래된 오프셋으로 초기화. 이미 존재하는 메시지 모두에 대해 처리를 실시.
   none   : 유효한 오프셋 커밋 정보가 없을 때 예외를 반환. KafkaConsumer.seek 메소드를 이용해 명시적으로 오프셋 지정해야 함.
               독자적인 정책에 따라 오프셋 재설정.
               
2.3 파티션 재배치(Partition Reassignment)
 
   2.3.1 개요
- 파티션의 복제본(replica)은 어느 하나의 브로커에 보관되어 있다. 복제본을 재배치하는 이유는 클러스터의 브로커를 증감시키는 경우다.
   브로커를 감소시키는 경우 다른 브로커로 이동시켜 필요한 복제본 수를 확보. 
   브로커를 증가시키는 경우 메시지의 송수신 부하를 균등하게 배분.
   
   2.3.2 재배치 방법
- kafka-reassign-partitions 스크립트를 이용. 

2.4 파티션 수 결정.

	2.4.1 클러스터의 메시지 송수신 : ???
	2.4.2 컨슈머 그룹의 할당 : 메시지 분산 수신을 위해 파티션 수가 컨슈머보다 많아야 한다. 
	2.4.3 브로커가 사용하는 디스크 : 브로커가 사용하는 디스크는 RAID 메커니즘을 통하지 않고 직접 사용하는 것이 바람직하다.
	                                              브로커가 여러 대의 디스크를 사용할 때 복제본 단위로 이용할 디스크를 분리하는 구조.
	                                              사용하지 않는 디스크가 존재하지 않으려면 디스크 수 이상 파티션 수가 클러스터 전체에서 필요.
	                                              
2.5 복제본 수 결정.

	2.5.1 min.insync.replicas : ISR 의 복제본이 최소 몇개나 필요한지 설정.
	                                   브로커는 메시지 수신한 직후 디스크에 flush 한다는 보장을 하지 않음. 복제본이 안전 장치.
	                                   재배치 수 >= min.insync.replicas + 브로커의 장애 허용 대수
	                                   	                                   
	2.5.2 토픽을 만들 때 Live Broker 대수 : 토픽 작성 시 재배치 수를 지정. 이때 정상 동작하는 브로커가 재배치 수 이상 존재하지 않으면
															토픽 작성이 실패한다.
														재배치 수 <= 브로커 총수 - 브로커의 장애 허용 대수
														
    주키퍼 등의 다른 컴포넌트와 균형도 고려해야 한다. 														 
  